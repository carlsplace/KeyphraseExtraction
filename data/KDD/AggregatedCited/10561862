Diagnosing_VBG memory_NN leaks_NNS using_VBG graph_NN mining_NN on_IN heap_NN dumps_NNS
Memory_NN leaks_NNS are_VBP caused_VBN by_IN software_NN programs_NNS that_WDT prevent_VBP the_DT reclamation_NN of_IN memory_NN that_WDT is_VBZ no_DT longer_RBR in_IN use_NN ._.
They_PRP can_MD cause_VB significant_JJ slowdowns_NNS ,_, exhaustion_NN of_IN available_JJ storage_NN space_NN and_CC ,_, eventually_RB ,_, application_NN crashes_NNS ._.
Detecting_VBG memory_NN leaks_NNS is_VBZ challenging_JJ because_IN real-world_JJ applications_NNS are_VBP built_VBN on_IN multiple_JJ layers_NNS of_IN software_NN frameworks_NNS ,_, making_VBG it_PRP difficult_JJ for_IN a_DT developer_NN to_TO know_VB whether_IN observed_VBN references_NNS to_TO objects_NNS are_VBP legitimate_JJ or_CC the_DT cause_NN of_IN a_DT leak_NN ._.
We_PRP present_VBP a_DT graph_NN mining_NN solution_NN to_TO this_DT problem_NN wherein_WRB we_PRP analyze_VBP heap_NN dumps_VBZ to_TO automatically_RB identify_VB subgraphs_NNS which_WDT could_MD represent_VB potential_JJ memory_NN leak_NN sources_NNS ._.
Although_IN heap_NN dumps_NNS are_VBP commonly_RB analyzed_VBN in_IN existing_VBG heap_NN profiling_NN tools_NNS ,_, our_PRP$ work_NN is_VBZ the_DT first_JJ to_TO apply_VB a_DT graph_NN grammar_NN mining_NN solution_NN to_TO this_DT problem_NN ._.
Unlike_IN classical_JJ graph_NN mining_NN work_NN ,_, we_PRP show_VBP that_IN it_PRP suffices_VBZ to_TO mine_VB the_DT dominator_NN tree_NN of_IN the_DT heap_NN dump_NN ,_, which_WDT is_VBZ significantly_RB smaller_JJR than_IN the_DT underlying_JJ graph_NN ._.
Our_PRP$ approach_NN identifies_VBZ not_RB just_RB leaking_VBG candidates_NNS and_CC their_PRP$ structure_NN ,_, but_CC also_RB provides_VBZ aggregate_JJ information_NN about_IN the_DT access_NN path_NN to_TO the_DT leaks_NNS ._.
We_PRP demonstrate_VBP several_JJ synthetic_NN as_RB well_RB as_IN real-world_JJ examples_NNS of_IN heap_NN dumps_VBZ for_IN which_WDT our_PRP$ approach_NN provides_VBZ more_JJR insight_NN into_IN the_DT problem_NN than_IN state-of-the-art_JJ tools_NNS such_JJ as_IN Eclipse_NNP 's_POS MAT_NNP ._.
ied_VBN object_NN may_MD be_VB a_DT bit_NN longer_RB ._.
3_LS ._.
RELATED_NNS WORK_VBP Debugging_NN via_IN Memory_NN Snapshots_NNS ._.
Analyzing_VBG heap_NN memory_NN snapshots_NNS has_VBZ a_DT long_JJ tradition_NN in_IN the_DT area_NN of_IN debugging_NN ._.
Recent_JJ work_NN on_IN the_DT memory_NN leak_NN detection_NN =_JJ -_: =[_NN 7_CD ,_, 17_CD ,_, 10_CD ,_, 4_CD -RRB-_-RRB- -_: =_JJ -_: ,_, the_DT bloat_NN detection_NN -LRB-_-LRB- 16_CD ,_, 11_CD ,_, 3_CD -RRB-_-RRB- ,_, the_DT ownership_NN detection_NN and_CC summarization_NN -LRB-_-LRB- 8_CD -RRB-_-RRB- ,_, and_CC the_DT source_NN of_IN excessive_JJ memory_NN footprints_NNS detection_NN -LRB-_-LRB- 9_CD -RRB-_-RRB- ,_, all_DT leverages_VBZ the_DT memory_NN graph_NN to_TO warn_VB the_DT potential_JJ perf_NN
